/* 题目：对于任意非负整数, 统计其二进制展开中 数位1 的总数*/

/* 详解：http://dsa.cs.tsinghua.edu.cn/~deng/ds/src_link/countones/countones_2.cpp.htm */

#include <iostream>

using namespace std;

/*
    #define 标识符 字符串 : 
        
        其中'#'表明这是一条预处理命令, 'define'为宏定义命令, '标识符'为所定义的宏名, '字符串' 可以是常数、表达式、格式串等。

　　例: #define M (a+b)

    　　它的作用是指定标识符M来代替表达式(a+b), 在编写源程序时, 所有的(a+b)都可由M代替, 而对源程序作编译时, 将先由预处理程序进行宏代换, 
        即用(a+b)表达式去置换所有的宏名M, 然后再进行编译。
*/

#define POW(c) (1 << (c)) // 将 1 转换为二进制, 接着左移 c 位, 即为 2^c

#define MASK(c) (((unsigned long) -1) / (POW(POW(c)) + 1))  // 效果: 以2^c位为单位分组，相间地全0和全1
                                                            // (unsigned long) -1 = 1111 1111 1111 1111 1111 1111 1111 1111
                                                            // (POW(POW(c))) = 2^(2^c), (POW(POW(2))) = 2^(2^2) = 1 0000

// MASK(0) = 55555555(h) = 0101 0101 0101 0101 0101 0101 0101 0101(b)
// MASK(1) = 33333333(h) = 0011 0011 0011 0011 0011 0011 0011 0011(b)
// MASK(2) = 0f0f0f0f(h) = 0000 1111 0000 1111 0000 1111 0000 1111(b)
// MASK(3) = 00ff00ff(h) = 0000 0000 1111 1111 0000 0000 1111 1111(b)
// MASK(4) = 0000ffff(h) = 0000 0000 0000 0000 1111 1111 1111 1111(b)

#define ROUND(n, c) (((n) & MASK(c)) + ((n) >> POW(c) & MASK(c)))  // 运算优先级：先右移，再位与
//过程：以2^c位为单位分组，相邻的组两两捉对累加，累加值用原2^(c + 1)位就地记录
//输出：n的二进制展开中，以2^(c + 1)位为单位分组，各组数值已经分别等于原先这2^(c + 1)位中1的数目

int countOnes ( unsigned int n ) { 
   n = ROUND ( n, 0 ); //以02位为单位分组，各组内前01位与后01位累加，得到原先这02位中1的数目
   n = ROUND ( n, 1 ); //以04位为单位分组，各组内前02位与后02位累加，得到原先这04位中1的数目
   n = ROUND ( n, 2 ); //以08位为单位分组，各组内前04位与后04位累加，得到原先这08位中1的数目
   n = ROUND ( n, 3 ); //以16位为单位分组，各组内前08位与后08位累加，得到原先这16位中1的数目
   n = ROUND ( n, 4 ); //以32位为单位分组，各组内前16位与后16位累加，得到原先这32位中1的数目
   return n; 
} 

int main(){
 
    cout << countOnes(100);
}

/*
    分析: 100(d) = 110 0100

        ROUND ( n, 0 ): 
        
            (110 0100) & (0101 0101 0101 0101 0101 0101 0101 0101) = 100 0100

            (110 0100) << 1 = (011 0010)  // 后01位

            (011 0010) & (0101 0101 0101 0101 0101 0101 0101 0101) = 1 000‬0

            100 0100 + 1 0000 = 101 0100

            结果: 以02位为单位分组, 各组内前01位(100 0100)与后01位(1 0000)累加,
                 得到原先这02位中1的数目 110 0100 变成 101 0100

        ROUND ( n, 1 ): 

            (101 0100) & (0011 0011 0011 0011 0011 0011 0011 0011) = 1 0000

            (101 0100) << 2 = (1 0101)  // 后02位

            (1 0101) & (0011 0011 0011 0011 0011 0011 0011 0011) = 1 000‬1

            1 0000 + 1 0001 = 10 0001

            结果: 以04位为单位分组, 各组内前02位(1 0000)与后02位(1 0001 )累加, 
                 得到原先这02位中1的数目 1 0000 变成 101 0100
    
    
    时间复杂度: O(log_2 W) = O(logW) = O(loglogn), W = O(log_2 n) 为整数的位宽
    
               通常将 O(loglogn) 视作常数

*/